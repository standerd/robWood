{"ast":null,"code":"// ------------------------------------------\n// Rellax.js\n// Buttery smooth parallax library\n// Copyright (c) 2016 Moe Amaya (@moeamaya)\n// MIT license\n//\n// Thanks to Paraxify.js and Jaime Cabllero\n// for parallax concepts\n// ------------------------------------------\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.Rellax = factory();\n  }\n})(typeof window !== \"undefined\" ? window : global, function () {\n  var Rellax = function (el, options) {\n    \"use strict\";\n\n    var self = Object.create(Rellax.prototype);\n    var posY = 0;\n    var screenY = 0;\n    var posX = 0;\n    var screenX = 0;\n    var blocks = [];\n    var pause = true; // check what requestAnimationFrame to use, and if\n    // it's not supported, use the onscroll event\n\n    var loop = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function (callback) {\n      return setTimeout(callback, 1000 / 60);\n    }; // store the id for later use\n\n\n    var loopId = null; // Test via a getter in the options object to see if the passive property is accessed\n\n    var supportsPassive = false;\n\n    try {\n      var opts = Object.defineProperty({}, 'passive', {\n        get: function () {\n          supportsPassive = true;\n        }\n      });\n      window.addEventListener(\"testPassive\", null, opts);\n      window.removeEventListener(\"testPassive\", null, opts);\n    } catch (e) {} // check what cancelAnimation method to use\n\n\n    var clearLoop = window.cancelAnimationFrame || window.mozCancelAnimationFrame || clearTimeout; // check which transform property to use\n\n    var transformProp = window.transformProp || function () {\n      var testEl = document.createElement('div');\n\n      if (testEl.style.transform === null) {\n        var vendors = ['Webkit', 'Moz', 'ms'];\n\n        for (var vendor in vendors) {\n          if (testEl.style[vendors[vendor] + 'Transform'] !== undefined) {\n            return vendors[vendor] + 'Transform';\n          }\n        }\n      }\n\n      return 'transform';\n    }(); // Default Settings\n\n\n    self.options = {\n      speed: -2,\n      center: false,\n      wrapper: null,\n      relativeToWrapper: false,\n      round: true,\n      vertical: true,\n      horizontal: false,\n      callback: function () {}\n    }; // User defined options (might have more in the future)\n\n    if (options) {\n      Object.keys(options).forEach(function (key) {\n        self.options[key] = options[key];\n      });\n    } // By default, rellax class\n\n\n    if (!el) {\n      el = '.rellax';\n    } // check if el is a className or a node\n\n\n    var elements = typeof el === 'string' ? document.querySelectorAll(el) : [el]; // Now query selector\n\n    if (elements.length > 0) {\n      self.elems = elements;\n    } // The elements don't exist\n    else {\n        console.warn(\"Rellax: The elements you're trying to select don't exist.\");\n        return;\n      } // Has a wrapper and it exists\n\n\n    if (self.options.wrapper) {\n      if (!self.options.wrapper.nodeType) {\n        var wrapper = document.querySelector(self.options.wrapper);\n\n        if (wrapper) {\n          self.options.wrapper = wrapper;\n        } else {\n          console.warn(\"Rellax: The wrapper you're trying to use doesn't exist.\");\n          return;\n        }\n      }\n    } // Get and cache initial position of all elements\n\n\n    var cacheBlocks = function () {\n      for (var i = 0; i < self.elems.length; i++) {\n        var block = createBlock(self.elems[i]);\n        blocks.push(block);\n      }\n    }; // Let's kick this script off\n    // Build array for cached element values\n\n\n    var init = function () {\n      for (var i = 0; i < blocks.length; i++) {\n        self.elems[i].style.cssText = blocks[i].style;\n      }\n\n      blocks = [];\n      screenY = window.innerHeight;\n      screenX = window.innerWidth;\n      setPosition();\n      cacheBlocks();\n      animate(); // If paused, unpause and set listener for window resizing events\n\n      if (pause) {\n        window.addEventListener('resize', init);\n        pause = false; // Start the loop\n\n        update();\n      }\n    }; // We want to cache the parallax blocks'\n    // values: base, top, height, speed\n    // el: is dom object, return: el cache values\n\n\n    var createBlock = function (el) {\n      var dataPercentage = el.getAttribute('data-rellax-percentage');\n      var dataSpeed = el.getAttribute('data-rellax-speed');\n      var dataZindex = el.getAttribute('data-rellax-zindex') || 0;\n      var dataMin = el.getAttribute('data-rellax-min');\n      var dataMax = el.getAttribute('data-rellax-max'); // initializing at scrollY = 0 (top of browser), scrollX = 0 (left of browser)\n      // ensures elements are positioned based on HTML layout.\n      //\n      // If the element has the percentage attribute, the posY and posX needs to be\n      // the current scroll position's value, so that the elements are still positioned based on HTML layout\n\n      var wrapperPosY = self.options.wrapper ? self.options.wrapper.scrollTop : window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop; // If the option relativeToWrapper is true, use the wrappers offset to top, subtracted from the current page scroll.\n\n      if (self.options.relativeToWrapper) {\n        var scrollPosY = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;\n        wrapperPosY = scrollPosY - self.options.wrapper.offsetTop;\n      }\n\n      var posY = self.options.vertical ? dataPercentage || self.options.center ? wrapperPosY : 0 : 0;\n      var posX = self.options.horizontal ? dataPercentage || self.options.center ? self.options.wrapper ? self.options.wrapper.scrollLeft : window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft : 0 : 0;\n      var blockTop = posY + el.getBoundingClientRect().top;\n      var blockHeight = el.clientHeight || el.offsetHeight || el.scrollHeight;\n      var blockLeft = posX + el.getBoundingClientRect().left;\n      var blockWidth = el.clientWidth || el.offsetWidth || el.scrollWidth; // apparently parallax equation everyone uses\n\n      var percentageY = dataPercentage ? dataPercentage : (posY - blockTop + screenY) / (blockHeight + screenY);\n      var percentageX = dataPercentage ? dataPercentage : (posX - blockLeft + screenX) / (blockWidth + screenX);\n\n      if (self.options.center) {\n        percentageX = 0.5;\n        percentageY = 0.5;\n      } // Optional individual block speed as data attr, otherwise global speed\n\n\n      var speed = dataSpeed ? dataSpeed : self.options.speed;\n      var bases = updatePosition(percentageX, percentageY, speed); // ~~Store non-translate3d transforms~~\n      // Store inline styles and extract transforms\n\n      var style = el.style.cssText;\n      var transform = ''; // Check if there's an inline styled transform\n\n      var searchResult = /transform\\s*:/i.exec(style);\n\n      if (searchResult) {\n        // Get the index of the transform\n        var index = searchResult.index; // Trim the style to the transform point and get the following semi-colon index\n\n        var trimmedStyle = style.slice(index);\n        var delimiter = trimmedStyle.indexOf(';'); // Remove \"transform\" string and save the attribute\n\n        if (delimiter) {\n          transform = \" \" + trimmedStyle.slice(11, delimiter).replace(/\\s/g, '');\n        } else {\n          transform = \" \" + trimmedStyle.slice(11).replace(/\\s/g, '');\n        }\n      }\n\n      return {\n        baseX: bases.x,\n        baseY: bases.y,\n        top: blockTop,\n        left: blockLeft,\n        height: blockHeight,\n        width: blockWidth,\n        speed: speed,\n        style: style,\n        transform: transform,\n        zindex: dataZindex,\n        min: dataMin,\n        max: dataMax\n      };\n    }; // set scroll position (posY, posX)\n    // side effect method is not ideal, but okay for now\n    // returns true if the scroll changed, false if nothing happened\n\n\n    var setPosition = function () {\n      var oldY = posY;\n      var oldX = posX;\n      posY = self.options.wrapper ? self.options.wrapper.scrollTop : (document.documentElement || document.body.parentNode || document.body).scrollTop || window.pageYOffset;\n      posX = self.options.wrapper ? self.options.wrapper.scrollLeft : (document.documentElement || document.body.parentNode || document.body).scrollLeft || window.pageXOffset; // If option relativeToWrapper is true, use relative wrapper value instead.\n\n      if (self.options.relativeToWrapper) {\n        var scrollPosY = (document.documentElement || document.body.parentNode || document.body).scrollTop || window.pageYOffset;\n        posY = scrollPosY - self.options.wrapper.offsetTop;\n      }\n\n      if (oldY != posY && self.options.vertical) {\n        // scroll changed, return true\n        return true;\n      }\n\n      if (oldX != posX && self.options.horizontal) {\n        // scroll changed, return true\n        return true;\n      } // scroll did not change\n\n\n      return false;\n    }; // Ahh a pure function, gets new transform value\n    // based on scrollPosition and speed\n    // Allow for decimal pixel values\n\n\n    var updatePosition = function (percentageX, percentageY, speed) {\n      var result = {};\n      var valueX = speed * (100 * (1 - percentageX));\n      var valueY = speed * (100 * (1 - percentageY));\n      result.x = self.options.round ? Math.round(valueX) : Math.round(valueX * 100) / 100;\n      result.y = self.options.round ? Math.round(valueY) : Math.round(valueY * 100) / 100;\n      return result;\n    }; // Remove event listeners and loop again\n\n\n    var deferredUpdate = function () {\n      window.removeEventListener('resize', deferredUpdate);\n      window.removeEventListener('orientationchange', deferredUpdate);\n      (self.options.wrapper ? self.options.wrapper : window).removeEventListener('scroll', deferredUpdate);\n      (self.options.wrapper ? self.options.wrapper : document).removeEventListener('touchmove', deferredUpdate); // loop again\n\n      loopId = loop(update);\n    }; // Loop\n\n\n    var update = function () {\n      if (setPosition() && pause === false) {\n        animate(); // loop again\n\n        loopId = loop(update);\n      } else {\n        loopId = null; // Don't animate until we get a position updating event\n\n        window.addEventListener('resize', deferredUpdate);\n        window.addEventListener('orientationchange', deferredUpdate);\n        (self.options.wrapper ? self.options.wrapper : window).addEventListener('scroll', deferredUpdate, supportsPassive ? {\n          passive: true\n        } : false);\n        (self.options.wrapper ? self.options.wrapper : document).addEventListener('touchmove', deferredUpdate, supportsPassive ? {\n          passive: true\n        } : false);\n      }\n    }; // Transform3d on parallax element\n\n\n    var animate = function () {\n      var positions;\n\n      for (var i = 0; i < self.elems.length; i++) {\n        var percentageY = (posY - blocks[i].top + screenY) / (blocks[i].height + screenY);\n        var percentageX = (posX - blocks[i].left + screenX) / (blocks[i].width + screenX); // Subtracting initialize value, so element stays in same spot as HTML\n\n        positions = updatePosition(percentageX, percentageY, blocks[i].speed); // - blocks[i].baseX;\n\n        var positionY = positions.y - blocks[i].baseY;\n        var positionX = positions.x - blocks[i].baseX; // The next two \"if\" blocks go like this:\n        // Check if a limit is defined (first \"min\", then \"max\");\n        // Check if we need to change the Y or the X\n        // (Currently working only if just one of the axes is enabled)\n        // Then, check if the new position is inside the allowed limit\n        // If so, use new position. If not, set position to limit.\n        // Check if a min limit is defined\n\n        if (blocks[i].min !== null) {\n          if (self.options.vertical && !self.options.horizontal) {\n            positionY = positionY <= blocks[i].min ? blocks[i].min : positionY;\n          }\n\n          if (self.options.horizontal && !self.options.vertical) {\n            positionX = positionX <= blocks[i].min ? blocks[i].min : positionX;\n          }\n        } // Check if a max limit is defined\n\n\n        if (blocks[i].max !== null) {\n          if (self.options.vertical && !self.options.horizontal) {\n            positionY = positionY >= blocks[i].max ? blocks[i].max : positionY;\n          }\n\n          if (self.options.horizontal && !self.options.vertical) {\n            positionX = positionX >= blocks[i].max ? blocks[i].max : positionX;\n          }\n        }\n\n        var zindex = blocks[i].zindex; // Move that element\n        // (Set the new translation and append initial inline transforms.)\n\n        var translate = 'translate3d(' + (self.options.horizontal ? positionX : '0') + 'px,' + (self.options.vertical ? positionY : '0') + 'px,' + zindex + 'px) ' + blocks[i].transform;\n        self.elems[i].style[transformProp] = translate;\n      }\n\n      self.options.callback(positions);\n    };\n\n    self.destroy = function () {\n      for (var i = 0; i < self.elems.length; i++) {\n        self.elems[i].style.cssText = blocks[i].style;\n      } // Remove resize event listener if not pause, and pause\n\n\n      if (!pause) {\n        window.removeEventListener('resize', init);\n        pause = true;\n      } // Clear the animation loop to prevent possible memory leak\n\n\n      clearLoop(loopId);\n      loopId = null;\n    }; // Init\n\n\n    init(); // Allow to recalculate the initial values whenever we want\n\n    self.refresh = init;\n    return self;\n  };\n\n  return Rellax;\n});","map":{"version":3,"sources":["/Users/Dewald/Desktop/robWood/node_modules/rellax/rellax.js"],"names":["root","factory","define","amd","module","exports","Rellax","window","global","el","options","self","Object","create","prototype","posY","screenY","posX","screenX","blocks","pause","loop","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","msRequestAnimationFrame","oRequestAnimationFrame","callback","setTimeout","loopId","supportsPassive","opts","defineProperty","get","addEventListener","removeEventListener","e","clearLoop","cancelAnimationFrame","mozCancelAnimationFrame","clearTimeout","transformProp","testEl","document","createElement","style","transform","vendors","vendor","undefined","speed","center","wrapper","relativeToWrapper","round","vertical","horizontal","keys","forEach","key","elements","querySelectorAll","length","elems","console","warn","nodeType","querySelector","cacheBlocks","i","block","createBlock","push","init","cssText","innerHeight","innerWidth","setPosition","animate","update","dataPercentage","getAttribute","dataSpeed","dataZindex","dataMin","dataMax","wrapperPosY","scrollTop","pageYOffset","documentElement","body","scrollPosY","offsetTop","scrollLeft","pageXOffset","blockTop","getBoundingClientRect","top","blockHeight","clientHeight","offsetHeight","scrollHeight","blockLeft","left","blockWidth","clientWidth","offsetWidth","scrollWidth","percentageY","percentageX","bases","updatePosition","searchResult","exec","index","trimmedStyle","slice","delimiter","indexOf","replace","baseX","x","baseY","y","height","width","zindex","min","max","oldY","oldX","parentNode","result","valueX","valueY","Math","deferredUpdate","passive","positions","positionY","positionX","translate","destroy","refresh"],"mappings":"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","sourcesContent":["\n// ------------------------------------------\n// Rellax.js\n// Buttery smooth parallax library\n// Copyright (c) 2016 Moe Amaya (@moeamaya)\n// MIT license\n//\n// Thanks to Paraxify.js and Jaime Cabllero\n// for parallax concepts\n// ------------------------------------------\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.Rellax = factory();\n  }\n}(typeof window !== \"undefined\" ? window : global, function () {\n  var Rellax = function(el, options){\n    \"use strict\";\n\n    var self = Object.create(Rellax.prototype);\n\n    var posY = 0;\n    var screenY = 0;\n    var posX = 0;\n    var screenX = 0;\n    var blocks = [];\n    var pause = true;\n\n    // check what requestAnimationFrame to use, and if\n    // it's not supported, use the onscroll event\n    var loop = window.requestAnimationFrame ||\n      window.webkitRequestAnimationFrame ||\n      window.mozRequestAnimationFrame ||\n      window.msRequestAnimationFrame ||\n      window.oRequestAnimationFrame ||\n      function(callback){ return setTimeout(callback, 1000 / 60); };\n\n    // store the id for later use\n    var loopId = null;\n\n    // Test via a getter in the options object to see if the passive property is accessed\n    var supportsPassive = false;\n    try {\n      var opts = Object.defineProperty({}, 'passive', {\n        get: function() {\n          supportsPassive = true;\n        }\n      });\n      window.addEventListener(\"testPassive\", null, opts);\n      window.removeEventListener(\"testPassive\", null, opts);\n    } catch (e) {}\n\n    // check what cancelAnimation method to use\n    var clearLoop = window.cancelAnimationFrame || window.mozCancelAnimationFrame || clearTimeout;\n\n    // check which transform property to use\n    var transformProp = window.transformProp || (function(){\n        var testEl = document.createElement('div');\n        if (testEl.style.transform === null) {\n          var vendors = ['Webkit', 'Moz', 'ms'];\n          for (var vendor in vendors) {\n            if (testEl.style[ vendors[vendor] + 'Transform' ] !== undefined) {\n              return vendors[vendor] + 'Transform';\n            }\n          }\n        }\n        return 'transform';\n      })();\n\n    // Default Settings\n    self.options = {\n      speed: -2,\n      center: false,\n      wrapper: null,\n      relativeToWrapper: false,\n      round: true,\n      vertical: true,\n      horizontal: false,\n      callback: function() {},\n    };\n\n    // User defined options (might have more in the future)\n    if (options){\n      Object.keys(options).forEach(function(key){\n        self.options[key] = options[key];\n      });\n    }\n\n    // By default, rellax class\n    if (!el) {\n      el = '.rellax';\n    }\n\n    // check if el is a className or a node\n    var elements = typeof el === 'string' ? document.querySelectorAll(el) : [el];\n\n    // Now query selector\n    if (elements.length > 0) {\n      self.elems = elements;\n    }\n\n    // The elements don't exist\n    else {\n      console.warn(\"Rellax: The elements you're trying to select don't exist.\");\n      return;\n    }\n\n    // Has a wrapper and it exists\n    if (self.options.wrapper) {\n      if (!self.options.wrapper.nodeType) {\n        var wrapper = document.querySelector(self.options.wrapper);\n\n        if (wrapper) {\n          self.options.wrapper = wrapper;\n        } else {\n          console.warn(\"Rellax: The wrapper you're trying to use doesn't exist.\");\n          return;\n        }\n      }\n    }\n\n\n    // Get and cache initial position of all elements\n    var cacheBlocks = function() {\n      for (var i = 0; i < self.elems.length; i++){\n        var block = createBlock(self.elems[i]);\n        blocks.push(block);\n      }\n    };\n\n\n    // Let's kick this script off\n    // Build array for cached element values\n    var init = function() {\n      for (var i = 0; i < blocks.length; i++){\n        self.elems[i].style.cssText = blocks[i].style;\n      }\n\n      blocks = [];\n\n      screenY = window.innerHeight;\n      screenX = window.innerWidth;\n      setPosition();\n\n      cacheBlocks();\n\n      animate();\n\n      // If paused, unpause and set listener for window resizing events\n      if (pause) {\n        window.addEventListener('resize', init);\n        pause = false;\n        // Start the loop\n        update();\n      }\n    };\n\n    // We want to cache the parallax blocks'\n    // values: base, top, height, speed\n    // el: is dom object, return: el cache values\n    var createBlock = function(el) {\n      var dataPercentage = el.getAttribute( 'data-rellax-percentage' );\n      var dataSpeed = el.getAttribute( 'data-rellax-speed' );\n      var dataZindex = el.getAttribute( 'data-rellax-zindex' ) || 0;\n      var dataMin = el.getAttribute( 'data-rellax-min' );\n      var dataMax = el.getAttribute( 'data-rellax-max' );\n\n      // initializing at scrollY = 0 (top of browser), scrollX = 0 (left of browser)\n      // ensures elements are positioned based on HTML layout.\n      //\n      // If the element has the percentage attribute, the posY and posX needs to be\n      // the current scroll position's value, so that the elements are still positioned based on HTML layout\n      var wrapperPosY = self.options.wrapper ? self.options.wrapper.scrollTop : (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop);\n      // If the option relativeToWrapper is true, use the wrappers offset to top, subtracted from the current page scroll.\n      if (self.options.relativeToWrapper) {\n        var scrollPosY = (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop);\n        wrapperPosY = scrollPosY - self.options.wrapper.offsetTop;\n      }\n      var posY = self.options.vertical ? ( dataPercentage || self.options.center ? wrapperPosY : 0 ) : 0;\n      var posX = self.options.horizontal ? ( dataPercentage || self.options.center ? self.options.wrapper ? self.options.wrapper.scrollLeft : (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft) : 0 ) : 0;\n\n      var blockTop = posY + el.getBoundingClientRect().top;\n      var blockHeight = el.clientHeight || el.offsetHeight || el.scrollHeight;\n\n      var blockLeft = posX + el.getBoundingClientRect().left;\n      var blockWidth = el.clientWidth || el.offsetWidth || el.scrollWidth;\n\n      // apparently parallax equation everyone uses\n      var percentageY = dataPercentage ? dataPercentage : (posY - blockTop + screenY) / (blockHeight + screenY);\n      var percentageX = dataPercentage ? dataPercentage : (posX - blockLeft + screenX) / (blockWidth + screenX);\n      if(self.options.center){ percentageX = 0.5; percentageY = 0.5; }\n\n      // Optional individual block speed as data attr, otherwise global speed\n      var speed = dataSpeed ? dataSpeed : self.options.speed;\n\n      var bases = updatePosition(percentageX, percentageY, speed);\n\n      // ~~Store non-translate3d transforms~~\n      // Store inline styles and extract transforms\n      var style = el.style.cssText;\n      var transform = '';\n\n      // Check if there's an inline styled transform\n      var searchResult = /transform\\s*:/i.exec(style);\n      if (searchResult) {\n        // Get the index of the transform\n        var index = searchResult.index;\n\n        // Trim the style to the transform point and get the following semi-colon index\n        var trimmedStyle = style.slice(index);\n        var delimiter = trimmedStyle.indexOf(';');\n\n        // Remove \"transform\" string and save the attribute\n        if (delimiter) {\n          transform = \" \" + trimmedStyle.slice(11, delimiter).replace(/\\s/g,'');\n        } else {\n          transform = \" \" + trimmedStyle.slice(11).replace(/\\s/g,'');\n        }\n      }\n\n      return {\n        baseX: bases.x,\n        baseY: bases.y,\n        top: blockTop,\n        left: blockLeft,\n        height: blockHeight,\n        width: blockWidth,\n        speed: speed,\n        style: style,\n        transform: transform,\n        zindex: dataZindex,\n        min: dataMin,\n        max: dataMax\n      };\n    };\n\n    // set scroll position (posY, posX)\n    // side effect method is not ideal, but okay for now\n    // returns true if the scroll changed, false if nothing happened\n    var setPosition = function() {\n      var oldY = posY;\n      var oldX = posX;\n\n      posY = self.options.wrapper ? self.options.wrapper.scrollTop : (document.documentElement || document.body.parentNode || document.body).scrollTop || window.pageYOffset;\n      posX = self.options.wrapper ? self.options.wrapper.scrollLeft : (document.documentElement || document.body.parentNode || document.body).scrollLeft || window.pageXOffset;\n      // If option relativeToWrapper is true, use relative wrapper value instead.\n      if (self.options.relativeToWrapper) {\n        var scrollPosY = (document.documentElement || document.body.parentNode || document.body).scrollTop || window.pageYOffset;\n        posY = scrollPosY - self.options.wrapper.offsetTop;\n      }\n\n\n      if (oldY != posY && self.options.vertical) {\n        // scroll changed, return true\n        return true;\n      }\n\n      if (oldX != posX && self.options.horizontal) {\n        // scroll changed, return true\n        return true;\n      }\n\n      // scroll did not change\n      return false;\n    };\n\n    // Ahh a pure function, gets new transform value\n    // based on scrollPosition and speed\n    // Allow for decimal pixel values\n    var updatePosition = function(percentageX, percentageY, speed) {\n      var result = {};\n      var valueX = (speed * (100 * (1 - percentageX)));\n      var valueY = (speed * (100 * (1 - percentageY)));\n\n      result.x = self.options.round ? Math.round(valueX) : Math.round(valueX * 100) / 100;\n      result.y = self.options.round ? Math.round(valueY) : Math.round(valueY * 100) / 100;\n\n      return result;\n    };\n\n    // Remove event listeners and loop again\n    var deferredUpdate = function() {\n      window.removeEventListener('resize', deferredUpdate);\n      window.removeEventListener('orientationchange', deferredUpdate);\n      (self.options.wrapper ? self.options.wrapper : window).removeEventListener('scroll', deferredUpdate);\n      (self.options.wrapper ? self.options.wrapper : document).removeEventListener('touchmove', deferredUpdate);\n\n      // loop again\n      loopId = loop(update);\n    };\n\n    // Loop\n    var update = function() {\n      if (setPosition() && pause === false) {\n        animate();\n\n        // loop again\n        loopId = loop(update);\n      } else {\n        loopId = null;\n\n        // Don't animate until we get a position updating event\n        window.addEventListener('resize', deferredUpdate);\n        window.addEventListener('orientationchange', deferredUpdate);\n        (self.options.wrapper ? self.options.wrapper : window).addEventListener('scroll', deferredUpdate, supportsPassive ? { passive: true } : false);\n        (self.options.wrapper ? self.options.wrapper : document).addEventListener('touchmove', deferredUpdate, supportsPassive ? { passive: true } : false);\n      }\n    };\n\n    // Transform3d on parallax element\n    var animate = function() {\n      var positions;\n      for (var i = 0; i < self.elems.length; i++){\n        var percentageY = ((posY - blocks[i].top + screenY) / (blocks[i].height + screenY));\n        var percentageX = ((posX - blocks[i].left + screenX) / (blocks[i].width + screenX));\n\n        // Subtracting initialize value, so element stays in same spot as HTML\n        positions = updatePosition(percentageX, percentageY, blocks[i].speed);// - blocks[i].baseX;\n        var positionY = positions.y - blocks[i].baseY;\n        var positionX = positions.x - blocks[i].baseX;\n\n        // The next two \"if\" blocks go like this:\n        // Check if a limit is defined (first \"min\", then \"max\");\n        // Check if we need to change the Y or the X\n        // (Currently working only if just one of the axes is enabled)\n        // Then, check if the new position is inside the allowed limit\n        // If so, use new position. If not, set position to limit.\n\n        // Check if a min limit is defined\n        if (blocks[i].min !== null) {\n          if (self.options.vertical && !self.options.horizontal) {\n            positionY = positionY <= blocks[i].min ? blocks[i].min : positionY;\n          }\n          if (self.options.horizontal && !self.options.vertical) {\n            positionX = positionX <= blocks[i].min ? blocks[i].min : positionX;\n          }\n        }\n\n        // Check if a max limit is defined\n        if (blocks[i].max !== null) {\n          if (self.options.vertical && !self.options.horizontal) {\n            positionY = positionY >= blocks[i].max ? blocks[i].max : positionY;\n          }\n          if (self.options.horizontal && !self.options.vertical) {\n            positionX = positionX >= blocks[i].max ? blocks[i].max : positionX;\n          }\n        }\n\n        var zindex = blocks[i].zindex;\n\n        // Move that element\n        // (Set the new translation and append initial inline transforms.)\n        var translate = 'translate3d(' + (self.options.horizontal ? positionX : '0') + 'px,' + (self.options.vertical ? positionY : '0') + 'px,' + zindex + 'px) ' + blocks[i].transform;\n        self.elems[i].style[transformProp] = translate;\n      }\n      self.options.callback(positions);\n    };\n\n    self.destroy = function() {\n      for (var i = 0; i < self.elems.length; i++){\n        self.elems[i].style.cssText = blocks[i].style;\n      }\n\n      // Remove resize event listener if not pause, and pause\n      if (!pause) {\n        window.removeEventListener('resize', init);\n        pause = true;\n      }\n\n      // Clear the animation loop to prevent possible memory leak\n      clearLoop(loopId);\n      loopId = null;\n    };\n\n    // Init\n    init();\n\n    // Allow to recalculate the initial values whenever we want\n    self.refresh = init;\n\n    return self;\n  };\n  return Rellax;\n}));\n"]},"metadata":{},"sourceType":"script"}